'use strict';

var chai = require('chai');
var child_process = require('child_process');
var process = require('process');
var path = require('path');
var url = require('url');
require('../lib/bin.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var chai__default = /*#__PURE__*/_interopDefaultLegacy(chai);
var process__default = /*#__PURE__*/_interopDefaultLegacy(process);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

const {assert} = chai__default['default'];
const binPath = path__default['default'].join(path__default['default'].dirname(url.fileURLToPath((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('node-test/node-test-bin.js', document.baseURI).href)))), '../lib/bin.js');
async function execBin(cmd) {
  return new Promise((resolve, reject) => {
    child_process.exec(`"${ process__default['default'].execPath }" "${ binPath }" ${ cmd }`, (err, stdout, stderr) => {
      if (err) {
        err.stdout = stdout;
        err.stderr = stderr;
        return reject(err);
      }
      resolve({
        stdout,
        stderr
      });
    });
  });
}
describe('Bin', () => {
  it('usage', async () => {
    try {
      await execBin('');
      assert.fail('should have errored');
    } catch (e) {
      assert.strictEqual(e.stdout, '');
      assert.strictEqual(e.stderr, `Usage: cborg <command> <args>
Valid commands:
\thex2diag <hex input>
\thex2json [--pretty] <hex input>
\tjson2hex '<json input>'
`);
    }
  });
  it('bad cmd', async () => {
    try {
      await execBin('blip');
      assert.fail('should have errored');
    } catch (e) {
      assert.strictEqual(e.stdout, '');
      assert.strictEqual(e.stderr, `Unknown command: 'blip'
Usage: cborg <command> <args>
Valid commands:
\thex2diag <hex input>
\thex2json [--pretty] <hex input>
\tjson2hex '<json input>'
`);
    }
  });
  it('help', async () => {
    const {stdout, stderr} = await execBin('help');
    assert.strictEqual(stdout, '');
    assert.strictEqual(stderr, `Usage: cborg <command> <args>
Valid commands:
\thex2diag <hex input>
\thex2json [--pretty] <hex input>
\tjson2hex '<json input>'
`);
  });
  it('hex2json', async () => {
    const {stdout, stderr} = await execBin('hex2json a3616101616282020365736d696c6564f09f9880');
    assert.strictEqual(stderr, '');
    assert.strictEqual(stdout, '{"a":1,"b":[2,3],"smile":"\uD83D\uDE00"}\n');
    try {
      await execBin('hex2json');
      assert.fail('should have errored');
    } catch (e) {
      assert.strictEqual(e.stdout, '');
      assert.isTrue(e.stderr.startsWith('hex2json requires a hexadecimal input string\nUsage: '));
    }
  });
  it('hex2json pretty', async () => {
    const {stdout, stderr} = await execBin('hex2json --pretty a3616101616282020365736d696c6564f09f9880');
    assert.strictEqual(stderr, '');
    assert.strictEqual(stdout, `{
  "a": 1,
  "b": [
    2,
    3
  ],
  "smile": "ðŸ˜€"
}
`);
  });
  it('hex2diag', async () => {
    const {stdout, stderr} = await execBin('hex2diag a4616101616282020363627566440102036165736d696c6564f09f9880');
    assert.strictEqual(stderr, '');
    assert.strictEqual(stdout, `a4                                                # map(4)
  61                                              #   string(1)
    61                                            #     "a"
  01                                              #   uint(1)
  61                                              #   string(1)
    62                                            #     "b"
  82                                              #   array(2)
    02                                            #     uint(2)
    03                                            #     uint(3)
  63                                              #   string(3)
    627566                                        #     "buf"
  44                                              #   bytes(4)
    01020361                                      #     "\\x01\\x02\\x03a"
  65                                              #   string(5)
    736d696c65                                    #     "smile"
  64 f09f                                         #   string(2)
    f09f9880                                      #     "ðŸ˜€"
`);
    try {
      await execBin('hex2diag');
      assert.fail('should have errored');
    } catch (e) {
      assert.strictEqual(e.stdout, '');
      assert.isTrue(e.stderr.startsWith('hex2diag requires a hexadecimal input string\nUsage: '));
    }
  });
  it('json2hex', async () => {
    const {stdout, stderr} = await execBin('json2hex "{\\"a\\":1,\\"b\\":[2,3],\\"smile\\":\\"\uD83D\uDE00\\"}"');
    assert.strictEqual(stderr, '');
    assert.strictEqual(stdout, 'a3616101616282020365736d696c6564f09f9880\n');
    try {
      await execBin('json2hex');
      assert.fail('should have errored');
    } catch (e) {
      assert.strictEqual(e.stdout, '');
      assert.isTrue(e.stderr.startsWith('json2hex requires a JSON input string\nUsage: '));
    }
  });
});
