{"ast":null,"code":"var _objectSpread = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar getAbsolutePath = function getAbsolutePath(basePath, relativePath) {\n  if (relativePath[0] !== '.') {\n    return relativePath;\n  }\n\n  var stack = basePath.split('/');\n  var chunks = relativePath.split('/');\n  stack.pop();\n\n  for (var i = 0; i < chunks.length; i++) {\n    if (chunks[i] == '.') {\n      continue;\n    } else if (chunks[i] == '..') {\n      stack.pop();\n    } else {\n      stack.push(chunks[i]);\n    }\n  }\n\n  return stack.join('/');\n};\n\nvar getImportPath = function getImportPath(currentLocation, importLocation) {\n  var path = getAbsolutePath(currentLocation, importLocation);\n  var extension = path.slice((path.lastIndexOf(\".\") - 1 >>> 0) + 2);\n  return extension ? path : path.concat('.zok');\n};\n\nmodule.exports = function (dep) {\n  var zokrates = dep.zokrates,\n      stdlib = dep.stdlib;\n\n  var resolveFromStdlib = function resolveFromStdlib(currentLocation, importLocation) {\n    var key = getImportPath(currentLocation, importLocation);\n    var source = stdlib[key];\n    return source ? {\n      source: source,\n      location: key\n    } : null;\n  };\n\n  return {\n    compile: function compile(source) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var createConfig = function createConfig(config) {\n        return _objectSpread({\n          allow_unconstrained_variables: false\n        }, config);\n      };\n\n      var _options$location = options.location,\n          location = _options$location === void 0 ? \"main.zok\" : _options$location,\n          _options$resolveCallb = options.resolveCallback,\n          resolveCallback = _options$resolveCallb === void 0 ? function () {\n        return null;\n      } : _options$resolveCallb,\n          _options$config = options.config,\n          config = _options$config === void 0 ? {} : _options$config;\n\n      var callback = function callback(currentLocation, importLocation) {\n        return resolveFromStdlib(currentLocation, importLocation) || resolveCallback(currentLocation, importLocation);\n      };\n\n      var _zokrates$compile = zokrates.compile(source, location, callback, createConfig(config)),\n          program = _zokrates$compile.program,\n          abi = _zokrates$compile.abi;\n\n      return {\n        program: new Uint8Array(program),\n        abi: abi\n      };\n    },\n    setup: function setup(program) {\n      var _zokrates$setup = zokrates.setup(program),\n          vk = _zokrates$setup.vk,\n          pk = _zokrates$setup.pk;\n\n      return {\n        vk: vk,\n        pk: new Uint8Array(pk)\n      };\n    },\n    computeWitness: function computeWitness(artifacts, args) {\n      var program = artifacts.program,\n          abi = artifacts.abi;\n      return zokrates.compute_witness(program, abi, JSON.stringify(Array.from(args)));\n    },\n    exportSolidityVerifier: function exportSolidityVerifier(verificationKey, abiVersion) {\n      return zokrates.export_solidity_verifier(verificationKey, abiVersion);\n    },\n    generateProof: function generateProof(program, witness, provingKey) {\n      return zokrates.generate_proof(program, witness, provingKey);\n    },\n    verify: function verify(verificationKey, proof) {\n      return zokrates.verify(verificationKey, proof);\n    }\n  };\n};","map":{"version":3,"sources":["/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/zokrates-js/wrapper.js"],"names":["getAbsolutePath","basePath","relativePath","stack","split","chunks","pop","i","length","push","join","getImportPath","currentLocation","importLocation","path","extension","slice","lastIndexOf","concat","module","exports","dep","zokrates","stdlib","resolveFromStdlib","key","source","location","compile","options","createConfig","config","allow_unconstrained_variables","resolveCallback","callback","program","abi","Uint8Array","setup","vk","pk","computeWitness","artifacts","args","compute_witness","JSON","stringify","Array","from","exportSolidityVerifier","verificationKey","abiVersion","export_solidity_verifier","generateProof","witness","provingKey","generate_proof","verify","proof"],"mappings":";;AAAA,IAAMA,eAAe,GAAG,SAAlBA,eAAkB,CAACC,QAAD,EAAWC,YAAX,EAA4B;AAChD,MAAIA,YAAY,CAAC,CAAD,CAAZ,KAAoB,GAAxB,EAA6B;AACzB,WAAOA,YAAP;AACH;;AACD,MAAIC,KAAK,GAAGF,QAAQ,CAACG,KAAT,CAAe,GAAf,CAAZ;AACA,MAAIC,MAAM,GAAGH,YAAY,CAACE,KAAb,CAAmB,GAAnB,CAAb;AACAD,EAAAA,KAAK,CAACG,GAAN;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACG,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC,QAAIF,MAAM,CAACE,CAAD,CAAN,IAAa,GAAjB,EAAsB;AAClB;AACH,KAFD,MAEO,IAAIF,MAAM,CAACE,CAAD,CAAN,IAAa,IAAjB,EAAuB;AAC1BJ,MAAAA,KAAK,CAACG,GAAN;AACH,KAFM,MAEA;AACHH,MAAAA,KAAK,CAACM,IAAN,CAAWJ,MAAM,CAACE,CAAD,CAAjB;AACH;AACJ;;AACD,SAAOJ,KAAK,CAACO,IAAN,CAAW,GAAX,CAAP;AACH,CAlBD;;AAoBA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,eAAD,EAAkBC,cAAlB,EAAqC;AACvD,MAAIC,IAAI,GAAGd,eAAe,CAACY,eAAD,EAAkBC,cAAlB,CAA1B;AACA,MAAME,SAAS,GAAGD,IAAI,CAACE,KAAL,CAAW,CAACF,IAAI,CAACG,WAAL,CAAiB,GAAjB,IAAwB,CAAxB,KAA8B,CAA/B,IAAoC,CAA/C,CAAlB;AACA,SAAOF,SAAS,GAAGD,IAAH,GAAUA,IAAI,CAACI,MAAL,CAAY,MAAZ,CAA1B;AACH,CAJD;;AAMAC,MAAM,CAACC,OAAP,GAAiB,UAACC,GAAD,EAAS;AAAA,MAEdC,QAFc,GAEOD,GAFP,CAEdC,QAFc;AAAA,MAEJC,MAFI,GAEOF,GAFP,CAEJE,MAFI;;AAItB,MAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACZ,eAAD,EAAkBC,cAAlB,EAAqC;AAC3D,QAAIY,GAAG,GAAGd,aAAa,CAACC,eAAD,EAAkBC,cAAlB,CAAvB;AACA,QAAIa,MAAM,GAAGH,MAAM,CAACE,GAAD,CAAnB;AACA,WAAOC,MAAM,GAAG;AAAEA,MAAAA,MAAM,EAANA,MAAF;AAAUC,MAAAA,QAAQ,EAAEF;AAApB,KAAH,GAA+B,IAA5C;AACH,GAJD;;AAMA,SAAO;AACHG,IAAAA,OAAO,EAAE,iBAACF,MAAD,EAA0B;AAAA,UAAjBG,OAAiB,uEAAP,EAAO;;AAC/B,UAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,MAAD;AAAA;AACjBC,UAAAA,6BAA6B,EAAE;AADd,WAEdD,MAFc;AAAA,OAArB;;AAD+B,8BAK8CF,OAL9C,CAKvBF,QALuB;AAAA,UAKvBA,QALuB,kCAKZ,UALY;AAAA,kCAK8CE,OAL9C,CAKAI,eALA;AAAA,UAKAA,eALA,sCAKkB;AAAA,eAAM,IAAN;AAAA,OALlB;AAAA,4BAK8CJ,OAL9C,CAK8BE,MAL9B;AAAA,UAK8BA,MAL9B,gCAKuC,EALvC;;AAM/B,UAAMG,QAAQ,GAAG,SAAXA,QAAW,CAACtB,eAAD,EAAkBC,cAAlB,EAAqC;AAClD,eAAOW,iBAAiB,CAACZ,eAAD,EAAkBC,cAAlB,CAAjB,IAAsDoB,eAAe,CAACrB,eAAD,EAAkBC,cAAlB,CAA5E;AACH,OAFD;;AAN+B,8BASNS,QAAQ,CAACM,OAAT,CAAiBF,MAAjB,EAAyBC,QAAzB,EAAmCO,QAAnC,EAA6CJ,YAAY,CAACC,MAAD,CAAzD,CATM;AAAA,UASvBI,OATuB,qBASvBA,OATuB;AAAA,UASdC,GATc,qBASdA,GATc;;AAU/B,aAAO;AACHD,QAAAA,OAAO,EAAE,IAAIE,UAAJ,CAAeF,OAAf,CADN;AAEHC,QAAAA,GAAG,EAAHA;AAFG,OAAP;AAIH,KAfE;AAgBHE,IAAAA,KAAK,EAAE,eAACH,OAAD,EAAa;AAAA,4BACGb,QAAQ,CAACgB,KAAT,CAAeH,OAAf,CADH;AAAA,UACRI,EADQ,mBACRA,EADQ;AAAA,UACJC,EADI,mBACJA,EADI;;AAEhB,aAAO;AACHD,QAAAA,EAAE,EAAFA,EADG;AAEHC,QAAAA,EAAE,EAAE,IAAIH,UAAJ,CAAeG,EAAf;AAFD,OAAP;AAIH,KAtBE;AAuBHC,IAAAA,cAAc,EAAE,wBAACC,SAAD,EAAYC,IAAZ,EAAqB;AAAA,UACzBR,OADyB,GACRO,SADQ,CACzBP,OADyB;AAAA,UAChBC,GADgB,GACRM,SADQ,CAChBN,GADgB;AAEjC,aAAOd,QAAQ,CAACsB,eAAT,CAAyBT,OAAzB,EAAkCC,GAAlC,EAAuCS,IAAI,CAACC,SAAL,CAAeC,KAAK,CAACC,IAAN,CAAWL,IAAX,CAAf,CAAvC,CAAP;AACH,KA1BE;AA2BHM,IAAAA,sBAAsB,EAAE,gCAACC,eAAD,EAAkBC,UAAlB,EAAiC;AACrD,aAAO7B,QAAQ,CAAC8B,wBAAT,CAAkCF,eAAlC,EAAmDC,UAAnD,CAAP;AACH,KA7BE;AA8BHE,IAAAA,aAAa,EAAE,uBAAClB,OAAD,EAAUmB,OAAV,EAAmBC,UAAnB,EAAkC;AAC7C,aAAOjC,QAAQ,CAACkC,cAAT,CAAwBrB,OAAxB,EAAiCmB,OAAjC,EAA0CC,UAA1C,CAAP;AACH,KAhCE;AAiCHE,IAAAA,MAAM,EAAE,gBAACP,eAAD,EAAkBQ,KAAlB,EAA4B;AAChC,aAAOpC,QAAQ,CAACmC,MAAT,CAAgBP,eAAhB,EAAiCQ,KAAjC,CAAP;AACH;AAnCE,GAAP;AAqCH,CA/CD","sourcesContent":["const getAbsolutePath = (basePath, relativePath) => {\n    if (relativePath[0] !== '.') {\n        return relativePath;\n    }\n    var stack = basePath.split('/');\n    var chunks = relativePath.split('/');\n    stack.pop();\n\n    for (var i = 0; i < chunks.length; i++) {\n        if (chunks[i] == '.') {\n            continue;\n        } else if (chunks[i] == '..') {\n            stack.pop();\n        } else {\n            stack.push(chunks[i]);\n        }\n    }\n    return stack.join('/');\n}\n\nconst getImportPath = (currentLocation, importLocation) => {\n    let path = getAbsolutePath(currentLocation, importLocation);\n    const extension = path.slice((path.lastIndexOf(\".\") - 1 >>> 0) + 2);\n    return extension ? path : path.concat('.zok');\n}\n\nmodule.exports = (dep) => {\n\n    const { zokrates, stdlib } = dep;\n\n    const resolveFromStdlib = (currentLocation, importLocation) => {\n        let key = getImportPath(currentLocation, importLocation);\n        let source = stdlib[key];\n        return source ? { source, location: key } : null;\n    }\n\n    return {\n        compile: (source, options = {}) => {\n            const createConfig = (config) => ({\n                allow_unconstrained_variables: false,\n                ...config\n            });\n            const { location = \"main.zok\", resolveCallback = () => null, config = {} } = options;\n            const callback = (currentLocation, importLocation) => {\n                return resolveFromStdlib(currentLocation, importLocation) || resolveCallback(currentLocation, importLocation);\n            };\n            const { program, abi } = zokrates.compile(source, location, callback, createConfig(config));\n            return {\n                program: new Uint8Array(program),\n                abi\n            }\n        },\n        setup: (program) => {\n            const { vk, pk } = zokrates.setup(program);\n            return {\n                vk,\n                pk: new Uint8Array(pk)\n            };\n        },\n        computeWitness: (artifacts, args) => {\n            const { program, abi } = artifacts;\n            return zokrates.compute_witness(program, abi, JSON.stringify(Array.from(args)));\n        },\n        exportSolidityVerifier: (verificationKey, abiVersion) => {\n            return zokrates.export_solidity_verifier(verificationKey, abiVersion);\n        },\n        generateProof: (program, witness, provingKey) => {\n            return zokrates.generate_proof(program, witness, provingKey);\n        },\n        verify: (verificationKey, proof) => {\n            return zokrates.verify(verificationKey, proof);\n        }\n    }\n};"]},"metadata":{},"sourceType":"script"}