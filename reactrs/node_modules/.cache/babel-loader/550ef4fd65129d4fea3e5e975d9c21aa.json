{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('./unixfs'),\n    PBData = _require.Data;\n\nvar errcode = require('err-code');\n/**\n * @typedef {import('./types').Mtime} Mtime\n * @typedef {import('./types').MtimeLike} MtimeLike\n */\n\n\nvar types = ['raw', 'directory', 'file', 'metadata', 'symlink', 'hamt-sharded-directory'];\nvar dirTypes = ['directory', 'hamt-sharded-directory'];\nvar DEFAULT_FILE_MODE = parseInt('0644', 8);\nvar DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\n/**\n * @param {string | number | undefined} [mode]\n */\n\nfunction parseMode(mode) {\n  if (mode == null) {\n    return undefined;\n  }\n\n  if (typeof mode === 'number') {\n    return mode & 0xFFF;\n  }\n\n  mode = mode.toString();\n\n  if (mode.substring(0, 1) === '0') {\n    // octal string\n    return parseInt(mode, 8) & 0xFFF;\n  } // decimal string\n\n\n  return parseInt(mode, 10) & 0xFFF;\n}\n/**\n * @param {any} input\n */\n\n\nfunction parseMtime(input) {\n  if (input == null) {\n    return undefined;\n  }\n  /** @type {Mtime | undefined} */\n\n\n  var mtime; // { secs, nsecs }\n\n  if (input.secs != null) {\n    mtime = {\n      secs: input.secs,\n      nsecs: input.nsecs\n    };\n  } // UnixFS TimeSpec\n\n\n  if (input.Seconds != null) {\n    mtime = {\n      secs: input.Seconds,\n      nsecs: input.FractionalNanoseconds\n    };\n  } // process.hrtime()\n\n\n  if (Array.isArray(input)) {\n    mtime = {\n      secs: input[0],\n      nsecs: input[1]\n    };\n  } // Javascript Date\n\n\n  if (input instanceof Date) {\n    var ms = input.getTime();\n    var secs = Math.floor(ms / 1000);\n    mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n  }\n  /*\n  TODO: https://github.com/ipfs/aegir/issues/487\n   // process.hrtime.bigint()\n  if (input instanceof BigInt) {\n    const secs = input / BigInt(1e9)\n    const nsecs = input - (secs * BigInt(1e9))\n     mtime = {\n      secs: parseInt(secs.toString()),\n      nsecs: parseInt(nsecs.toString())\n    }\n  }\n  */\n\n\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined;\n  }\n\n  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {\n    throw errcode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');\n  }\n\n  return mtime;\n}\n\nvar Data = /*#__PURE__*/function () {\n  /**\n   * @param {object} [options]\n   * @param {string} [options.type='file']\n   * @param {Uint8Array} [options.data]\n   * @param {number[]} [options.blockSizes]\n   * @param {number} [options.hashType]\n   * @param {number} [options.fanout]\n   * @param {MtimeLike | null} [options.mtime]\n   * @param {number | string} [options.mode]\n   */\n  function Data() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      type: 'file'\n    };\n\n    _classCallCheck(this, Data);\n\n    var type = options.type,\n        data = options.data,\n        blockSizes = options.blockSizes,\n        hashType = options.hashType,\n        fanout = options.fanout,\n        mtime = options.mtime,\n        mode = options.mode;\n\n    if (type && !types.includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n\n    this.type = type || 'file';\n    this.data = data;\n    this.hashType = hashType;\n    this.fanout = fanout;\n    /** @type {number[]} */\n\n    this.blockSizes = blockSizes || [];\n    this._originalMode = 0;\n    this.mode = parseMode(mode);\n\n    if (mtime) {\n      this.mtime = parseMtime(mtime);\n\n      if (this.mtime && !this.mtime.nsecs) {\n        this.mtime.nsecs = 0;\n      }\n    }\n  }\n  /**\n   * @param {number | undefined} mode\n   */\n\n\n  _createClass(Data, [{\n    key: \"mode\",\n    get:\n    /**\n     * @returns {number | undefined}\n     */\n    function get() {\n      return this._mode;\n    },\n    set: function set(mode) {\n      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;\n      var parsedMode = parseMode(mode);\n\n      if (parsedMode !== undefined) {\n        this._mode = parsedMode;\n      }\n    }\n  }, {\n    key: \"isDirectory\",\n    value: function isDirectory() {\n      return Boolean(this.type && dirTypes.includes(this.type));\n    }\n    /**\n     * @param {number} size\n     */\n\n  }, {\n    key: \"addBlockSize\",\n    value: function addBlockSize(size) {\n      this.blockSizes.push(size);\n    }\n    /**\n     * @param {number} index\n     */\n\n  }, {\n    key: \"removeBlockSize\",\n    value: function removeBlockSize(index) {\n      this.blockSizes.splice(index, 1);\n    }\n    /**\n     * Returns `0` for directories or `data.length + sum(blockSizes)` for everything else\n     */\n\n  }, {\n    key: \"fileSize\",\n    value: function fileSize() {\n      if (this.isDirectory()) {\n        // dirs don't have file size\n        return 0;\n      }\n\n      var sum = 0;\n      this.blockSizes.forEach(function (size) {\n        sum += size;\n      });\n\n      if (this.data) {\n        sum += this.data.length;\n      }\n\n      return sum;\n    }\n    /**\n     * encode to protobuf Uint8Array\n     */\n\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      var type;\n\n      switch (this.type) {\n        case 'raw':\n          type = PBData.DataType.Raw;\n          break;\n\n        case 'directory':\n          type = PBData.DataType.Directory;\n          break;\n\n        case 'file':\n          type = PBData.DataType.File;\n          break;\n\n        case 'metadata':\n          type = PBData.DataType.Metadata;\n          break;\n\n        case 'symlink':\n          type = PBData.DataType.Symlink;\n          break;\n\n        case 'hamt-sharded-directory':\n          type = PBData.DataType.HAMTShard;\n          break;\n\n        default:\n          throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n      }\n\n      var data = this.data;\n\n      if (!this.data || !this.data.length) {\n        data = undefined;\n      }\n\n      var mode;\n\n      if (this.mode != null) {\n        mode = this._originalMode & 0xFFFFF000 | (parseMode(this.mode) || 0);\n\n        if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n          mode = undefined;\n        }\n\n        if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n          mode = undefined;\n        }\n      }\n\n      var mtime;\n\n      if (this.mtime != null) {\n        var parsed = parseMtime(this.mtime);\n\n        if (parsed) {\n          mtime = {\n            Seconds: parsed.secs,\n            FractionalNanoseconds: parsed.nsecs\n          };\n\n          if (mtime.FractionalNanoseconds === 0) {\n            delete mtime.FractionalNanoseconds;\n          }\n        }\n      }\n\n      var pbData = {\n        Type: type,\n        Data: data,\n        filesize: this.isDirectory() ? undefined : this.fileSize(),\n        blocksizes: this.blockSizes,\n        hashType: this.hashType,\n        fanout: this.fanout,\n        mode: mode,\n        mtime: mtime\n      };\n      return PBData.encode(pbData).finish();\n    }\n  }], [{\n    key: \"unmarshal\",\n    value:\n    /**\n     * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n     *\n     * @param {Uint8Array} marshaled\n     */\n    function unmarshal(marshaled) {\n      var message = PBData.decode(marshaled);\n      var decoded = PBData.toObject(message, {\n        defaults: false,\n        arrays: true,\n        longs: Number,\n        objects: false\n      });\n      var data = new Data({\n        type: types[decoded.Type],\n        data: decoded.Data,\n        blockSizes: decoded.blocksizes,\n        mode: decoded.mode,\n        mtime: decoded.mtime ? {\n          secs: decoded.mtime.Seconds,\n          nsecs: decoded.mtime.FractionalNanoseconds\n        } : undefined\n      }); // make sure we honour the original mode\n\n      data._originalMode = decoded.mode || 0;\n      return data;\n    }\n  }]);\n\n  return Data;\n}();\n\nmodule.exports = {\n  UnixFS: Data,\n  parseMode: parseMode,\n  parseMtime: parseMtime\n};","map":{"version":3,"sources":["/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/ipfs-unixfs/src/index.js"],"names":["require","PBData","Data","errcode","types","dirTypes","DEFAULT_FILE_MODE","parseInt","DEFAULT_DIRECTORY_MODE","parseMode","mode","undefined","toString","substring","parseMtime","input","mtime","secs","nsecs","Seconds","FractionalNanoseconds","Array","isArray","Date","ms","getTime","Math","floor","Object","prototype","hasOwnProperty","call","Error","options","type","data","blockSizes","hashType","fanout","includes","_originalMode","_mode","isDirectory","parsedMode","Boolean","size","push","index","splice","sum","forEach","length","DataType","Raw","Directory","File","Metadata","Symlink","HAMTShard","parsed","pbData","Type","filesize","fileSize","blocksizes","encode","finish","marshaled","message","decode","decoded","toObject","defaults","arrays","longs","Number","objects","module","exports","UnixFS"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {\n  Data: PBData\n} = require('./unixfs')\nconst errcode = require('err-code')\n\n/**\n * @typedef {import('./types').Mtime} Mtime\n * @typedef {import('./types').MtimeLike} MtimeLike\n */\n\nconst types = [\n  'raw',\n  'directory',\n  'file',\n  'metadata',\n  'symlink',\n  'hamt-sharded-directory'\n]\n\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n]\n\nconst DEFAULT_FILE_MODE = parseInt('0644', 8)\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)\n\n/**\n * @param {string | number | undefined} [mode]\n */\nfunction parseMode (mode) {\n  if (mode == null) {\n    return undefined\n  }\n\n  if (typeof mode === 'number') {\n    return mode & 0xFFF\n  }\n\n  mode = mode.toString()\n\n  if (mode.substring(0, 1) === '0') {\n    // octal string\n    return parseInt(mode, 8) & 0xFFF\n  }\n\n  // decimal string\n  return parseInt(mode, 10) & 0xFFF\n}\n\n/**\n * @param {any} input\n */\nfunction parseMtime (input) {\n  if (input == null) {\n    return undefined\n  }\n\n  /** @type {Mtime | undefined} */\n  let mtime\n\n  // { secs, nsecs }\n  if (input.secs != null) {\n    mtime = {\n      secs: input.secs,\n      nsecs: input.nsecs\n    }\n  }\n\n  // UnixFS TimeSpec\n  if (input.Seconds != null) {\n    mtime = {\n      secs: input.Seconds,\n      nsecs: input.FractionalNanoseconds\n    }\n  }\n\n  // process.hrtime()\n  if (Array.isArray(input)) {\n    mtime = {\n      secs: input[0],\n      nsecs: input[1]\n    }\n  }\n\n  // Javascript Date\n  if (input instanceof Date) {\n    const ms = input.getTime()\n    const secs = Math.floor(ms / 1000)\n\n    mtime = {\n      secs: secs,\n      nsecs: (ms - (secs * 1000)) * 1000\n    }\n  }\n\n  /*\n  TODO: https://github.com/ipfs/aegir/issues/487\n\n  // process.hrtime.bigint()\n  if (input instanceof BigInt) {\n    const secs = input / BigInt(1e9)\n    const nsecs = input - (secs * BigInt(1e9))\n\n    mtime = {\n      secs: parseInt(secs.toString()),\n      nsecs: parseInt(nsecs.toString())\n    }\n  }\n  */\n\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined\n  }\n\n  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {\n    throw errcode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS')\n  }\n\n  return mtime\n}\n\nclass Data {\n  /**\n   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n   *\n   * @param {Uint8Array} marshaled\n   */\n  static unmarshal (marshaled) {\n    const message = PBData.decode(marshaled)\n    const decoded = PBData.toObject(message, {\n      defaults: false,\n      arrays: true,\n      longs: Number,\n      objects: false\n    })\n\n    const data = new Data({\n      type: types[decoded.Type],\n      data: decoded.Data,\n      blockSizes: decoded.blocksizes,\n      mode: decoded.mode,\n      mtime: decoded.mtime\n        ? {\n            secs: decoded.mtime.Seconds,\n            nsecs: decoded.mtime.FractionalNanoseconds\n          }\n        : undefined\n    })\n\n    // make sure we honour the original mode\n    data._originalMode = decoded.mode || 0\n\n    return data\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {string} [options.type='file']\n   * @param {Uint8Array} [options.data]\n   * @param {number[]} [options.blockSizes]\n   * @param {number} [options.hashType]\n   * @param {number} [options.fanout]\n   * @param {MtimeLike | null} [options.mtime]\n   * @param {number | string} [options.mode]\n   */\n  constructor (options = {\n    type: 'file'\n  }) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = options\n\n    if (type && !types.includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE')\n    }\n\n    this.type = type || 'file'\n    this.data = data\n    this.hashType = hashType\n    this.fanout = fanout\n\n    /** @type {number[]} */\n    this.blockSizes = blockSizes || []\n    this._originalMode = 0\n    this.mode = parseMode(mode)\n\n    if (mtime) {\n      this.mtime = parseMtime(mtime)\n\n      if (this.mtime && !this.mtime.nsecs) {\n        this.mtime.nsecs = 0\n      }\n    }\n  }\n\n  /**\n   * @param {number | undefined} mode\n   */\n  set mode (mode) {\n    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE\n\n    const parsedMode = parseMode(mode)\n\n    if (parsedMode !== undefined) {\n      this._mode = parsedMode\n    }\n  }\n\n  /**\n   * @returns {number | undefined}\n   */\n  get mode () {\n    return this._mode\n  }\n\n  isDirectory () {\n    return Boolean(this.type && dirTypes.includes(this.type))\n  }\n\n  /**\n   * @param {number} size\n   */\n  addBlockSize (size) {\n    this.blockSizes.push(size)\n  }\n\n  /**\n   * @param {number} index\n   */\n  removeBlockSize (index) {\n    this.blockSizes.splice(index, 1)\n  }\n\n  /**\n   * Returns `0` for directories or `data.length + sum(blockSizes)` for everything else\n   */\n  fileSize () {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return 0\n    }\n\n    let sum = 0\n    this.blockSizes.forEach((size) => {\n      sum += size\n    })\n\n    if (this.data) {\n      sum += this.data.length\n    }\n\n    return sum\n  }\n\n  /**\n   * encode to protobuf Uint8Array\n   */\n  marshal () {\n    let type\n\n    switch (this.type) {\n      case 'raw': type = PBData.DataType.Raw; break\n      case 'directory': type = PBData.DataType.Directory; break\n      case 'file': type = PBData.DataType.File; break\n      case 'metadata': type = PBData.DataType.Metadata; break\n      case 'symlink': type = PBData.DataType.Symlink; break\n      case 'hamt-sharded-directory': type = PBData.DataType.HAMTShard; break\n      default:\n        throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE')\n    }\n\n    let data = this.data\n\n    if (!this.data || !this.data.length) {\n      data = undefined\n    }\n\n    let mode\n\n    if (this.mode != null) {\n      mode = (this._originalMode & 0xFFFFF000) | (parseMode(this.mode) || 0)\n\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined\n      }\n    }\n\n    let mtime\n\n    if (this.mtime != null) {\n      const parsed = parseMtime(this.mtime)\n\n      if (parsed) {\n        mtime = {\n          Seconds: parsed.secs,\n          FractionalNanoseconds: parsed.nsecs\n        }\n\n        if (mtime.FractionalNanoseconds === 0) {\n          delete mtime.FractionalNanoseconds\n        }\n      }\n    }\n\n    const pbData = {\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    }\n\n    return PBData.encode(pbData).finish()\n  }\n}\n\nmodule.exports = {\n  UnixFS: Data,\n  parseMode,\n  parseMtime\n}\n"]},"metadata":{},"sourceType":"script"}