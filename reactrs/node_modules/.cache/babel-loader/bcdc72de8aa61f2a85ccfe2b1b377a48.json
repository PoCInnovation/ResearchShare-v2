{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _require = require('multiformats/cid'),\n    CID = _require.CID;\n\nvar errCode = require('err-code');\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock\n * @param {AbortOptions} [options]\n */\n\n\nvar resolve = /*#__PURE__*/function () {\n  var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(cid, path, codecs, getBlock, options) {\n    var load, parts, value, lastCid, key;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            /**\n             * @param {CID} cid\n             */\n            load = /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cid) {\n                var codec, block;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return codecs.getCodec(cid.code);\n\n                      case 2:\n                        codec = _context.sent;\n                        _context.next = 5;\n                        return getBlock(cid, options);\n\n                      case 5:\n                        block = _context.sent;\n                        return _context.abrupt(\"return\", codec.decode(block));\n\n                      case 7:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function load(_x6) {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n\n            parts = path.split('/').filter(Boolean);\n            _context2.next = 4;\n            return _awaitAsyncGenerator(load(cid));\n\n          case 4:\n            value = _context2.sent;\n            lastCid = cid;\n\n            if (parts.length) {\n              _context2.next = 9;\n              break;\n            }\n\n            _context2.next = 9;\n            return {\n              value: value,\n              remainderPath: ''\n            };\n\n          case 9:\n            if (!parts.length) {\n              _context2.next = 27;\n              break;\n            }\n\n            key = parts.shift();\n\n            if (key) {\n              _context2.next = 13;\n              break;\n            }\n\n            throw errCode(new Error(\"Could not resolve path \\\"\".concat(path, \"\\\"\")), 'ERR_INVALID_PATH');\n\n          case 13:\n            if (!Object.prototype.hasOwnProperty.call(value, key)) {\n              _context2.next = 19;\n              break;\n            }\n\n            value = value[key];\n            _context2.next = 17;\n            return {\n              value: value,\n              remainderPath: parts.join('/')\n            };\n\n          case 17:\n            _context2.next = 20;\n            break;\n\n          case 19:\n            throw errCode(new Error(\"no link named \\\"\".concat(key, \"\\\" under \").concat(lastCid)), 'ERR_NO_LINK');\n\n          case 20:\n            if (!(value instanceof CID)) {\n              _context2.next = 25;\n              break;\n            }\n\n            lastCid = value;\n            _context2.next = 24;\n            return _awaitAsyncGenerator(load(value));\n\n          case 24:\n            value = _context2.sent;\n\n          case 25:\n            _context2.next = 9;\n            break;\n\n          case 27:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function resolve(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = resolve;","map":{"version":3,"sources":["/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/ipfs-http-client/src/lib/resolve.js"],"names":["require","CID","errCode","resolve","cid","path","codecs","getBlock","options","load","getCodec","code","codec","block","decode","parts","split","filter","Boolean","value","lastCid","length","remainderPath","key","shift","Error","Object","prototype","hasOwnProperty","call","join","module","exports"],"mappings":"AAAA;;;;;;;;;;eAEgBA,OAAO,CAAC,kBAAD,C;IAAfC,G,YAAAA,G;;AACR,IAAMC,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,OAAO;AAAA,wEAAG,kBAAkBC,GAAlB,EAAuBC,IAAvB,EAA6BC,MAA7B,EAAqCC,QAArC,EAA+CC,OAA/C;AAAA;AAAA;AAAA;AAAA;AAAA;AACd;AACF;AACA;AACQC,YAAAA,IAJQ;AAAA,mFAID,iBAAOL,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BACSE,MAAM,CAACI,QAAP,CAAgBN,GAAG,CAACO,IAApB,CADT;;AAAA;AACLC,wBAAAA,KADK;AAAA;AAAA,+BAESL,QAAQ,CAACH,GAAD,EAAMI,OAAN,CAFjB;;AAAA;AAELK,wBAAAA,KAFK;AAAA,yDAIJD,KAAK,CAACE,MAAN,CAAaD,KAAb,CAJI;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAJC;;AAAA,8BAIRJ,IAJQ;AAAA;AAAA;AAAA;;AAWRM,YAAAA,KAXQ,GAWAV,IAAI,CAACW,KAAL,CAAW,GAAX,EAAgBC,MAAhB,CAAuBC,OAAvB,CAXA;AAAA;AAAA,wCAYIT,IAAI,CAACL,GAAD,CAZR;;AAAA;AAYVe,YAAAA,KAZU;AAaVC,YAAAA,OAbU,GAaAhB,GAbA;;AAAA,gBAeTW,KAAK,CAACM,MAfG;AAAA;AAAA;AAAA;;AAAA;AAgBZ,mBAAM;AACJF,cAAAA,KAAK,EAALA,KADI;AAEJG,cAAAA,aAAa,EAAE;AAFX,aAAN;;AAhBY;AAAA,iBAuBPP,KAAK,CAACM,MAvBC;AAAA;AAAA;AAAA;;AAwBNE,YAAAA,GAxBM,GAwBAR,KAAK,CAACS,KAAN,EAxBA;;AAAA,gBA0BPD,GA1BO;AAAA;AAAA;AAAA;;AAAA,kBA2BJrB,OAAO,CAAC,IAAIuB,KAAJ,oCAAqCpB,IAArC,QAAD,EAAgD,kBAAhD,CA3BH;;AAAA;AAAA,iBA8BRqB,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCV,KAArC,EAA4CI,GAA5C,CA9BQ;AAAA;AAAA;AAAA;;AA+BVJ,YAAAA,KAAK,GAAGA,KAAK,CAACI,GAAD,CAAb;AA/BU;AAiCV,mBAAM;AACJJ,cAAAA,KAAK,EAALA,KADI;AAEJG,cAAAA,aAAa,EAAEP,KAAK,CAACe,IAAN,CAAW,GAAX;AAFX,aAAN;;AAjCU;AAAA;AAAA;;AAAA;AAAA,kBAsCJ5B,OAAO,CAAC,IAAIuB,KAAJ,2BAA4BF,GAA5B,sBAA0CH,OAA1C,EAAD,EAAuD,aAAvD,CAtCH;;AAAA;AAAA,kBAyCRD,KAAK,YAAYlB,GAzCT;AAAA;AAAA;AAAA;;AA0CVmB,YAAAA,OAAO,GAAGD,KAAV;AA1CU;AAAA,wCA2CIV,IAAI,CAACU,KAAD,CA3CR;;AAAA;AA2CVA,YAAAA,KA3CU;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAPhB,OAAO;AAAA;AAAA;AAAA,GAAb;;AAgDA4B,MAAM,CAACC,OAAP,GAAiB7B,OAAjB","sourcesContent":["'use strict'\n\nconst { CID } = require('multiformats/cid')\nconst errCode = require('err-code')\n\n/**\n * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions\n */\n\n/**\n * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n *\n * @param {CID} cid - the CID where the resolving starts\n * @param {string} path - the path that should be resolved\n * @param {import('ipfs-core-utils/src/multicodecs')} codecs\n * @param {(cid: CID, options?: AbortOptions) => Promise<Uint8Array>} getBlock\n * @param {AbortOptions} [options]\n */\nconst resolve = async function * (cid, path, codecs, getBlock, options) {\n  /**\n   * @param {CID} cid\n   */\n  const load = async (cid) => {\n    const codec = await codecs.getCodec(cid.code)\n    const block = await getBlock(cid, options)\n\n    return codec.decode(block)\n  }\n\n  const parts = path.split('/').filter(Boolean)\n  let value = await load(cid)\n  let lastCid = cid\n\n  if (!parts.length) {\n    yield {\n      value,\n      remainderPath: ''\n    }\n  }\n\n  // End iteration if there isn't a CID to follow any more\n  while (parts.length) {\n    const key = parts.shift()\n\n    if (!key) {\n      throw errCode(new Error(`Could not resolve path \"${path}\"`), 'ERR_INVALID_PATH')\n    }\n\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      value = value[key]\n\n      yield {\n        value,\n        remainderPath: parts.join('/')\n      }\n    } else {\n      throw errCode(new Error(`no link named \"${key}\" under ${lastCid}`), 'ERR_NO_LINK')\n    }\n\n    if (value instanceof CID) {\n      lastCid = value\n      value = await load(value)\n    }\n  }\n}\n\nmodule.exports = resolve\n"]},"metadata":{},"sourceType":"script"}