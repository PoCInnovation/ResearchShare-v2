{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar codec = require('./codec');\n\nvar protocols = require('./protocols-table');\n\nvar varint = require('varint');\n\nvar CID = require('cids');\n\nvar withIs = require('class-is');\n\nvar errCode = require('err-code');\n\nvar inspect = Symbol.for('nodejs.util.inspect.custom');\n\nvar uint8ArrayToString = require('uint8arrays/to-string');\n\nvar uint8ArrayEquals = require('uint8arrays/equals');\n\nvar resolvers = new Map();\n/**\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\n * a Uint8Array, String or another Multiaddr instance\n * public key.\n *\n * @class Multiaddr\n * @param {(string | Uint8Array | Multiaddr)} addr - If String or Uint8Array, needs to adhere\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\n\nvar Multiaddr = withIs.proto(function (addr) {\n  if (!(this instanceof Multiaddr)) {\n    return new Multiaddr(addr);\n  } // default\n\n\n  if (addr == null) {\n    addr = '';\n  }\n\n  if (addr instanceof Uint8Array) {\n    /**\n     * @type {Uint8Array} - The raw bytes representing this multiaddress\n     */\n    this.bytes = codec.fromBytes(addr);\n  } else if (typeof addr === 'string' || addr instanceof String) {\n    if (addr.length > 0 && addr.charAt(0) !== '/') {\n      throw new Error(\"multiaddr \\\"\".concat(addr, \"\\\" must start with a \\\"/\\\"\"));\n    }\n\n    this.bytes = codec.fromString(addr);\n  } else if (addr.bytes && addr.protos && addr.protoCodes) {\n    // Multiaddr\n    this.bytes = codec.fromBytes(addr.bytes); // validate + copy buffer\n  } else {\n    throw new Error('addr must be a string, Buffer, or another Multiaddr');\n  }\n}, {\n  className: 'Multiaddr',\n  symbolName: '@multiformats/js-multiaddr/multiaddr'\n});\n/**\n * Returns Multiaddr as a String\n *\n * @returns {string}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n * // '/ip4/127.0.0.1/tcp/4001'\n */\n\nMultiaddr.prototype.toString = function toString() {\n  return codec.bytesToString(this.bytes);\n};\n/**\n * Returns Multiaddr as a JSON encoded object\n *\n * @returns {string}\n * @example\n * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n * // '/ip4/127.0.0.1/tcp/4001'\n */\n\n\nMultiaddr.prototype.toJSON = Multiaddr.prototype.toString;\n/**\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\n *\n * @returns {{family: string, host: string, transport: string, port: number}}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: 4001 }\n */\n\nMultiaddr.prototype.toOptions = function toOptions() {\n  var opts = {};\n  var parsed = this.toString().split('/');\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6';\n  opts.host = parsed[2];\n  opts.transport = parsed[3];\n  opts.port = parseInt(parsed[4]);\n  return opts;\n};\n/**\n * Returns Multiaddr as a human-readable string.\n * For post Node.js v10.0.0.\n * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\n *\n * @returns {string}\n * @example\n * console.log(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n */\n\n\nMultiaddr.prototype[inspect] = function inspectCustom() {\n  return '<Multiaddr ' + uint8ArrayToString(this.bytes, 'base16') + ' - ' + codec.bytesToString(this.bytes) + '>';\n};\n/**\n * Returns Multiaddr as a human-readable string.\n * Fallback for pre Node.js v10.0.0.\n * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\n *\n * @returns {string}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n */\n\n\nMultiaddr.prototype.inspect = function inspect() {\n  return '<Multiaddr ' + uint8ArrayToString(this.bytes, 'base16') + ' - ' + codec.bytesToString(this.bytes) + '>';\n};\n/**\n * @typedef {object} protocol\n * @property {number} code\n * @property {number} size\n * @property {string} name\n * @property {boolean} [resolvable]\n * @property {boolean} [path]\n */\n\n/**\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n * left-to-right order. Each object contains the protocol code, protocol name,\n * and the size of its address space in bits.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {protocol[]} protocols - All the protocols the address is composed of\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n * // [ { code: 4, size: 32, name: 'ip4' },\n * //   { code: 6, size: 16, name: 'tcp' } ]\n */\n\n\nMultiaddr.prototype.protos = function protos() {\n  return this.protoCodes().map(function (code) {\n    return Object.assign({}, protocols(code));\n  });\n};\n/**\n * Returns the codes of the protocols in left-to-right order.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {Array<number>} protocol codes\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n * // [ 4, 6 ]\n */\n\n\nMultiaddr.prototype.protoCodes = function protoCodes() {\n  var codes = [];\n  var buf = this.bytes;\n  var i = 0;\n\n  while (i < buf.length) {\n    var code = varint.decode(buf, i);\n    var n = varint.decode.bytes;\n    var p = protocols(code);\n    var size = codec.sizeForAddr(p, buf.slice(i + n));\n    i += size + n;\n    codes.push(code);\n  }\n\n  return codes;\n};\n/**\n * Returns the names of the protocols in left-to-right order.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {Array.<string>} protocol names\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n * // [ 'ip4', 'tcp' ]\n */\n\n\nMultiaddr.prototype.protoNames = function protoNames() {\n  return this.protos().map(function (proto) {\n    return proto.name;\n  });\n};\n/**\n * Returns a tuple of parts\n *\n * @returns {[number, Uint8Array][]} tuples\n * @example\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n */\n\n\nMultiaddr.prototype.tuples = function tuples() {\n  return codec.bytesToTuples(this.bytes);\n};\n/**\n * Returns a tuple of string/number parts\n * - tuples[][0] = code of protocol\n * - tuples[][1] = contents of address\n *\n * @returns {[number, string|number][]} tuples\n * @example\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\n */\n\n\nMultiaddr.prototype.stringTuples = function stringTuples() {\n  var t = codec.bytesToTuples(this.bytes);\n  return codec.tuplesToStringTuples(t);\n};\n/**\n * Encapsulates a Multiaddr in another Multiaddr\n *\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\n * @returns {Multiaddr}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n *\n * mh3.toString()\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n */\n\n\nMultiaddr.prototype.encapsulate = function encapsulate(addr) {\n  addr = Multiaddr(addr);\n  return Multiaddr(this.toString() + addr.toString());\n};\n/**\n * Decapsulates a Multiaddr from another Multiaddr\n *\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\n * @returns {Multiaddr}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n *\n * mh3.decapsulate(mh2).toString()\n * // '/ip4/8.8.8.8/tcp/1080'\n */\n\n\nMultiaddr.prototype.decapsulate = function decapsulate(addr) {\n  addr = addr.toString();\n  var s = this.toString();\n  var i = s.lastIndexOf(addr);\n\n  if (i < 0) {\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr);\n  }\n\n  return Multiaddr(s.slice(0, i));\n};\n/**\n * A more reliable version of `decapsulate` if you are targeting a\n * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n * will be removed from the `Multiaddr`, and a new instance will be returned.\n * If the code is not present, the original `Multiaddr` is returned.\n *\n * @param {number} code - The code of the protocol to decapsulate from this Multiaddr\n * @returns {Multiaddr}\n * @example\n * const addr = Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>\n *\n * addr.decapsulateCode(421).toString()\n * // '/ip4/0.0.0.0/tcp/8080'\n *\n * Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n * // '/ip4/127.0.0.1/tcp/8080'\n */\n\n\nMultiaddr.prototype.decapsulateCode = function decapsulateCode(code) {\n  var tuples = this.tuples();\n\n  for (var i = tuples.length - 1; i >= 0; i--) {\n    if (tuples[i][0] === code) {\n      return Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)));\n    }\n  }\n\n  return this;\n};\n/**\n * Extract the peerId if the multiaddr contains one\n *\n * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\n *\n * // should return QmValidBase58string or null if the id is missing or invalid\n * const peerId = mh1.getPeerId()\n */\n\n\nMultiaddr.prototype.getPeerId = function getPeerId() {\n  var b58str = null;\n\n  try {\n    var tuples = this.stringTuples().filter(function (tuple) {\n      if (tuple[0] === protocols.names.ipfs.code) {\n        return true;\n      }\n    }); // Get the last id\n\n    b58str = tuples.pop()[1]; // Get multihash, unwrap from CID if needed\n\n    b58str = uint8ArrayToString(new CID(b58str).multihash, 'base58btc');\n  } catch (e) {\n    b58str = null;\n  }\n\n  return b58str;\n};\n/**\n * Extract the path if the multiaddr contains one\n *\n * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\n *\n * // should return utf8 string or null if the id is missing or invalid\n * const path = mh1.getPath()\n */\n\n\nMultiaddr.prototype.getPath = function getPath() {\n  var path = null;\n\n  try {\n    path = this.stringTuples().filter(function (tuple) {\n      var proto = protocols(tuple[0]);\n\n      if (proto.path) {\n        return true;\n      }\n    })[0][1];\n  } catch (e) {\n    path = null;\n  }\n\n  return path;\n};\n/**\n * Checks if two Multiaddrs are the same\n *\n * @param {Multiaddr} addr\n * @returns {Bool}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * mh1.equals(mh1)\n * // true\n *\n * mh1.equals(mh2)\n * // false\n */\n\n\nMultiaddr.prototype.equals = function equals(addr) {\n  return uint8ArrayEquals(this.bytes, addr.bytes);\n};\n/**\n * Resolve multiaddr if containing resolvable hostname.\n *\n * @returns {Promise<Array<Multiaddr>>}\n * @example\n * Multiaddr.resolvers.set('dnsaddr', resolverFunction)\n * const mh1 = Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n * const resolvedMultiaddrs = await mh1.resolve()\n * // [\n * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\n * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\n * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>\n * // ]\n */\n\n\nMultiaddr.prototype.resolve = /*#__PURE__*/function () {\n  var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var resolvableProto, resolver, addresses;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            resolvableProto = this.protos().find(function (p) {\n              return p.resolvable;\n            }); // Multiaddr is not resolvable?\n\n            if (resolvableProto) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", [this]);\n\n          case 3:\n            resolver = resolvers.get(resolvableProto.name);\n\n            if (resolver) {\n              _context.next = 6;\n              break;\n            }\n\n            throw errCode(new Error(\"no available resolver for \".concat(resolvableProto.name)), 'ERR_NO_AVAILABLE_RESOLVER');\n\n          case 6:\n            _context.next = 8;\n            return resolver(this);\n\n          case 8:\n            addresses = _context.sent;\n            return _context.abrupt(\"return\", addresses.map(function (a) {\n              return Multiaddr(a);\n            }));\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  function resolve() {\n    return _resolve.apply(this, arguments);\n  }\n\n  return resolve;\n}();\n/**\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\n * is left out: in Node (and most network systems) the protocol is unknowable\n * given only the address.\n *\n * Has to be a ThinWaist Address, otherwise throws error\n *\n * @returns {{family: string, address: string, port: number}}\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\n */\n\n\nMultiaddr.prototype.nodeAddress = function nodeAddress() {\n  var codes = this.protoCodes();\n  var names = this.protoNames();\n  var parts = this.toString().split('/').slice(1);\n\n  if (parts.length < 4) {\n    throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".');\n  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\n    throw new Error(\"no protocol with name: \\\"'\".concat(names[0], \"'\\\". Must have a valid family name: \\\"{ip4, ip6, dns4, dns6}\\\".\"));\n  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {\n    throw new Error(\"no protocol with name: \\\"'\".concat(names[1], \"'\\\". Must have a valid transport protocol: \\\"{tcp, udp}\\\".\"));\n  }\n\n  return {\n    family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,\n    address: parts[1],\n    // ip addr\n    port: parseInt(parts[3]) // tcp or udp port\n\n  };\n};\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @param {{family: string, address: string, port: number}} addr\n * @param {string} transport\n * @returns {Multiaddr} multiaddr\n * @throws {Error} Throws error if addr is not truthy\n * @throws {Error} Throws error if transport is not truthy\n * @example\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\n\n\nMultiaddr.fromNodeAddress = function fromNodeAddress(addr, transport) {\n  if (!addr) throw new Error('requires node address object');\n  if (!transport) throw new Error('requires transport protocol');\n  var ip;\n\n  switch (addr.family) {\n    case 'IPv4':\n      ip = 'ip4';\n      break;\n\n    case 'IPv6':\n      ip = 'ip6';\n      break;\n\n    default:\n      throw Error(\"Invalid addr family. Got '\".concat(addr.family, \"' instead of 'IPv4' or 'IPv6'\"));\n  }\n\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'));\n}; // TODO find a better example, not sure about it's good enough\n\n/**\n * Returns if a Multiaddr is a Thin Waist address or not.\n *\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\n *\n * `{IPv4, IPv6}/{TCP, UDP}`\n *\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\n * @returns {boolean} isThinWaistAddress\n * @example\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\n * mh1.isThinWaistAddress()\n * // true\n * mh2.isThinWaistAddress()\n * // true\n * mh3.isThinWaistAddress()\n * // false\n */\n\n\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress(addr) {\n  var protos = (addr || this).protos();\n\n  if (protos.length !== 2) {\n    return false;\n  }\n\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\n    return false;\n  }\n\n  if (protos[1].code !== 6 && protos[1].code !== 273) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Object containing table, names and codes of all supported protocols.\n * To get the protocol values from a Multiaddr, you can use\n * [`.protos()`](#multiaddrprotos),\n * [`.protoCodes()`](#multiaddrprotocodes) or\n * [`.protoNames()`](#multiaddrprotonames)\n *\n * @instance\n * @returns {{table: Array, names: Object, codes: Object}}\n *\n */\n\n\nMultiaddr.protocols = protocols;\n/**\n * Returns if something is a Multiaddr that is a name\n *\n * @param {Multiaddr} addr\n * @returns {Bool} isName\n */\n\nMultiaddr.isName = function isName(addr) {\n  if (!Multiaddr.isMultiaddr(addr)) {\n    return false;\n  } // if a part of the multiaddr is resolvable, then return true\n\n\n  return addr.protos().some(function (proto) {\n    return proto.resolvable;\n  });\n};\n/**\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\n *\n * @async\n * @param {Multiaddr} addr\n * @returns {Multiaddr[]}\n */\n\n\nMultiaddr.resolve = function resolve(addr) {\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n    return Promise.reject(Error('not a valid name'));\n  }\n  /*\n   * Needs more consideration from spec design:\n   *   - what to return\n   *   - how to achieve it in the browser?\n   */\n\n\n  return Promise.reject(new Error('not implemented yet'));\n};\n\nMultiaddr.resolvers = resolvers;\nexports = module.exports = Multiaddr;","map":{"version":3,"sources":["/home/thalusa/Documents/ResearchShare-v2/node_modules/multiaddr/src/index.js"],"names":["codec","require","protocols","varint","CID","withIs","errCode","inspect","Symbol","for","uint8ArrayToString","uint8ArrayEquals","resolvers","Map","Multiaddr","proto","addr","Uint8Array","bytes","fromBytes","String","length","charAt","Error","fromString","protos","protoCodes","className","symbolName","prototype","toString","bytesToString","toJSON","toOptions","opts","parsed","split","family","host","transport","port","parseInt","inspectCustom","map","code","Object","assign","codes","buf","i","decode","n","p","size","sizeForAddr","slice","push","protoNames","name","tuples","bytesToTuples","stringTuples","t","tuplesToStringTuples","encapsulate","decapsulate","s","lastIndexOf","decapsulateCode","tuplesToBytes","getPeerId","b58str","filter","tuple","names","ipfs","pop","multihash","e","getPath","path","equals","resolve","resolvableProto","find","resolvable","resolver","get","addresses","a","nodeAddress","parts","address","fromNodeAddress","ip","join","isThinWaistAddress","isName","isMultiaddr","some","Promise","reject","exports","module"],"mappings":"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","sourcesContent":["'use strict'\n\nconst codec = require('./codec')\nconst protocols = require('./protocols-table')\nconst varint = require('varint')\nconst CID = require('cids')\nconst withIs = require('class-is')\nconst errCode = require('err-code')\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nconst uint8ArrayToString = require('uint8arrays/to-string')\nconst uint8ArrayEquals = require('uint8arrays/equals')\n\nconst resolvers = new Map()\n\n/**\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\n * a Uint8Array, String or another Multiaddr instance\n * public key.\n *\n * @class Multiaddr\n * @param {(string | Uint8Array | Multiaddr)} addr - If String or Uint8Array, needs to adhere\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\nconst Multiaddr = withIs.proto(function (addr) {\n  if (!(this instanceof Multiaddr)) {\n    return new Multiaddr(addr)\n  }\n\n  // default\n  if (addr == null) {\n    addr = ''\n  }\n\n  if (addr instanceof Uint8Array) {\n    /**\n     * @type {Uint8Array} - The raw bytes representing this multiaddress\n     */\n    this.bytes = codec.fromBytes(addr)\n  } else if (typeof addr === 'string' || addr instanceof String) {\n    if (addr.length > 0 && addr.charAt(0) !== '/') {\n      throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n    }\n    this.bytes = codec.fromString(addr)\n  } else if (addr.bytes && addr.protos && addr.protoCodes) { // Multiaddr\n    this.bytes = codec.fromBytes(addr.bytes) // validate + copy buffer\n  } else {\n    throw new Error('addr must be a string, Buffer, or another Multiaddr')\n  }\n}, { className: 'Multiaddr', symbolName: '@multiformats/js-multiaddr/multiaddr' })\n\n/**\n * Returns Multiaddr as a String\n *\n * @returns {string}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n * // '/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.toString = function toString () {\n  return codec.bytesToString(this.bytes)\n}\n\n/**\n * Returns Multiaddr as a JSON encoded object\n *\n * @returns {string}\n * @example\n * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n * // '/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.toJSON = Multiaddr.prototype.toString\n\n/**\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\n *\n * @returns {{family: string, host: string, transport: string, port: number}}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: 4001 }\n */\nMultiaddr.prototype.toOptions = function toOptions () {\n  const opts = {}\n  const parsed = this.toString().split('/')\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6'\n  opts.host = parsed[2]\n  opts.transport = parsed[3]\n  opts.port = parseInt(parsed[4])\n  return opts\n}\n\n/**\n * Returns Multiaddr as a human-readable string.\n * For post Node.js v10.0.0.\n * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\n *\n * @returns {string}\n * @example\n * console.log(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n */\nMultiaddr.prototype[inspect] = function inspectCustom () {\n  return '<Multiaddr ' +\n    uint8ArrayToString(this.bytes, 'base16') + ' - ' +\n    codec.bytesToString(this.bytes) + '>'\n}\n\n/**\n * Returns Multiaddr as a human-readable string.\n * Fallback for pre Node.js v10.0.0.\n * https://nodejs.org/api/deprecations.html#deprecations_dep0079_custom_inspection_function_on_objects_via_inspect\n *\n * @returns {string}\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\n */\nMultiaddr.prototype.inspect = function inspect () {\n  return '<Multiaddr ' +\n    uint8ArrayToString(this.bytes, 'base16') + ' - ' +\n    codec.bytesToString(this.bytes) + '>'\n}\n\n/**\n * @typedef {object} protocol\n * @property {number} code\n * @property {number} size\n * @property {string} name\n * @property {boolean} [resolvable]\n * @property {boolean} [path]\n */\n\n/**\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n * left-to-right order. Each object contains the protocol code, protocol name,\n * and the size of its address space in bits.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {protocol[]} protocols - All the protocols the address is composed of\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n * // [ { code: 4, size: 32, name: 'ip4' },\n * //   { code: 6, size: 16, name: 'tcp' } ]\n */\nMultiaddr.prototype.protos = function protos () {\n  return this.protoCodes().map(code => Object.assign({}, protocols(code)))\n}\n\n/**\n * Returns the codes of the protocols in left-to-right order.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {Array<number>} protocol codes\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n * // [ 4, 6 ]\n */\nMultiaddr.prototype.protoCodes = function protoCodes () {\n  const codes = []\n  const buf = this.bytes\n  let i = 0\n  while (i < buf.length) {\n    const code = varint.decode(buf, i)\n    const n = varint.decode.bytes\n\n    const p = protocols(code)\n    const size = codec.sizeForAddr(p, buf.slice(i + n))\n\n    i += (size + n)\n    codes.push(code)\n  }\n\n  return codes\n}\n\n/**\n * Returns the names of the protocols in left-to-right order.\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n *\n * @returns {Array.<string>} protocol names\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n * // [ 'ip4', 'tcp' ]\n */\nMultiaddr.prototype.protoNames = function protoNames () {\n  return this.protos().map(proto => proto.name)\n}\n\n/**\n * Returns a tuple of parts\n *\n * @returns {[number, Uint8Array][]} tuples\n * @example\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n */\nMultiaddr.prototype.tuples = function tuples () {\n  return codec.bytesToTuples(this.bytes)\n}\n\n/**\n * Returns a tuple of string/number parts\n * - tuples[][0] = code of protocol\n * - tuples[][1] = contents of address\n *\n * @returns {[number, string|number][]} tuples\n * @example\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\n */\nMultiaddr.prototype.stringTuples = function stringTuples () {\n  const t = codec.bytesToTuples(this.bytes)\n  return codec.tuplesToStringTuples(t)\n}\n\n/**\n * Encapsulates a Multiaddr in another Multiaddr\n *\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\n * @returns {Multiaddr}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n *\n * mh3.toString()\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n */\nMultiaddr.prototype.encapsulate = function encapsulate (addr) {\n  addr = Multiaddr(addr)\n  return Multiaddr(this.toString() + addr.toString())\n}\n\n/**\n * Decapsulates a Multiaddr from another Multiaddr\n *\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\n * @returns {Multiaddr}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\n *\n * mh3.decapsulate(mh2).toString()\n * // '/ip4/8.8.8.8/tcp/1080'\n */\nMultiaddr.prototype.decapsulate = function decapsulate (addr) {\n  addr = addr.toString()\n  const s = this.toString()\n  const i = s.lastIndexOf(addr)\n  if (i < 0) {\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr)\n  }\n  return Multiaddr(s.slice(0, i))\n}\n\n/**\n * A more reliable version of `decapsulate` if you are targeting a\n * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n * will be removed from the `Multiaddr`, and a new instance will be returned.\n * If the code is not present, the original `Multiaddr` is returned.\n *\n * @param {number} code - The code of the protocol to decapsulate from this Multiaddr\n * @returns {Multiaddr}\n * @example\n * const addr = Multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n * // <Multiaddr 0400... - /ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC>\n *\n * addr.decapsulateCode(421).toString()\n * // '/ip4/0.0.0.0/tcp/8080'\n *\n * Multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n * // '/ip4/127.0.0.1/tcp/8080'\n */\nMultiaddr.prototype.decapsulateCode = function decapsulateCode (code) {\n  const tuples = this.tuples()\n  for (let i = tuples.length - 1; i >= 0; i--) {\n    if (tuples[i][0] === code) {\n      return Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)))\n    }\n  }\n  return this\n}\n\n/**\n * Extract the peerId if the multiaddr contains one\n *\n * @returns {string | null} peerId - The id of the peer or null if invalid or missing from the ma\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\n *\n * // should return QmValidBase58string or null if the id is missing or invalid\n * const peerId = mh1.getPeerId()\n */\nMultiaddr.prototype.getPeerId = function getPeerId () {\n  let b58str = null\n  try {\n    const tuples = this.stringTuples().filter((tuple) => {\n      if (tuple[0] === protocols.names.ipfs.code) {\n        return true\n      }\n    })\n\n    // Get the last id\n    b58str = tuples.pop()[1]\n    // Get multihash, unwrap from CID if needed\n    b58str = uint8ArrayToString(new CID(b58str).multihash, 'base58btc')\n  } catch (e) {\n    b58str = null\n  }\n\n  return b58str\n}\n\n/**\n * Extract the path if the multiaddr contains one\n *\n * @returns {string | null} path - The path of the multiaddr, or null if no path protocol is present\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\n *\n * // should return utf8 string or null if the id is missing or invalid\n * const path = mh1.getPath()\n */\nMultiaddr.prototype.getPath = function getPath () {\n  let path = null\n  try {\n    path = this.stringTuples().filter((tuple) => {\n      const proto = protocols(tuple[0])\n      if (proto.path) {\n        return true\n      }\n    })[0][1]\n  } catch (e) {\n    path = null\n  }\n\n  return path\n}\n\n/**\n * Checks if two Multiaddrs are the same\n *\n * @param {Multiaddr} addr\n * @returns {Bool}\n * @example\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\n *\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n *\n * mh1.equals(mh1)\n * // true\n *\n * mh1.equals(mh2)\n * // false\n */\nMultiaddr.prototype.equals = function equals (addr) {\n  return uint8ArrayEquals(this.bytes, addr.bytes)\n}\n\n/**\n * Resolve multiaddr if containing resolvable hostname.\n *\n * @returns {Promise<Array<Multiaddr>>}\n * @example\n * Multiaddr.resolvers.set('dnsaddr', resolverFunction)\n * const mh1 = Multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n * const resolvedMultiaddrs = await mh1.resolve()\n * // [\n * //   <Multiaddr 04934b5353060fa1a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\n * //   <Multiaddr 04934b53530601bbde03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>,\n * //   <Multiaddr 04934b535391020fa1cc03a503221220c10f9319dac35c270a6b74cd644cb3acfc1f6efc8c821f8eb282599fd1814f64 - /ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb>\n * // ]\n */\nMultiaddr.prototype.resolve = async function resolve () {\n  const resolvableProto = this.protos().find((p) => p.resolvable)\n\n  // Multiaddr is not resolvable?\n  if (!resolvableProto) {\n    return [this]\n  }\n\n  const resolver = resolvers.get(resolvableProto.name)\n  if (!resolver) {\n    throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), 'ERR_NO_AVAILABLE_RESOLVER')\n  }\n\n  const addresses = await resolver(this)\n  return addresses.map(a => Multiaddr(a))\n}\n\n/**\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\n * is left out: in Node (and most network systems) the protocol is unknowable\n * given only the address.\n *\n * Has to be a ThinWaist Address, otherwise throws error\n *\n * @returns {{family: string, address: string, port: number}}\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\n * @example\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\n */\nMultiaddr.prototype.nodeAddress = function nodeAddress () {\n  const codes = this.protoCodes()\n  const names = this.protoNames()\n  const parts = this.toString().split('/').slice(1)\n\n  if (parts.length < 4) {\n    throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".')\n  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\n    throw new Error(`no protocol with name: \"'${names[0]}'\". Must have a valid family name: \"{ip4, ip6, dns4, dns6}\".`)\n  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {\n    throw new Error(`no protocol with name: \"'${names[1]}'\". Must have a valid transport protocol: \"{tcp, udp}\".`)\n  }\n\n  return {\n    family: (codes[0] === 41 || codes[0] === 55) ? 6 : 4,\n    address: parts[1], // ip addr\n    port: parseInt(parts[3]) // tcp or udp port\n  }\n}\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @param {{family: string, address: string, port: number}} addr\n * @param {string} transport\n * @returns {Multiaddr} multiaddr\n * @throws {Error} Throws error if addr is not truthy\n * @throws {Error} Throws error if transport is not truthy\n * @example\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n */\nMultiaddr.fromNodeAddress = function fromNodeAddress (addr, transport) {\n  if (!addr) throw new Error('requires node address object')\n  if (!transport) throw new Error('requires transport protocol')\n  let ip\n  switch (addr.family) {\n    case 'IPv4':\n      ip = 'ip4'\n      break\n    case 'IPv6':\n      ip = 'ip6'\n      break\n    default:\n      throw Error(`Invalid addr family. Got '${addr.family}' instead of 'IPv4' or 'IPv6'`)\n  }\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'))\n}\n\n// TODO find a better example, not sure about it's good enough\n/**\n * Returns if a Multiaddr is a Thin Waist address or not.\n *\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\n *\n * `{IPv4, IPv6}/{TCP, UDP}`\n *\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\n * @returns {boolean} isThinWaistAddress\n * @example\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\n * const mh3 = mh1.encapsulate(mh2)\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\n * mh1.isThinWaistAddress()\n * // true\n * mh2.isThinWaistAddress()\n * // true\n * mh3.isThinWaistAddress()\n * // false\n */\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress (addr) {\n  const protos = (addr || this).protos()\n\n  if (protos.length !== 2) {\n    return false\n  }\n\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\n    return false\n  }\n  if (protos[1].code !== 6 && protos[1].code !== 273) {\n    return false\n  }\n  return true\n}\n\n/**\n * Object containing table, names and codes of all supported protocols.\n * To get the protocol values from a Multiaddr, you can use\n * [`.protos()`](#multiaddrprotos),\n * [`.protoCodes()`](#multiaddrprotocodes) or\n * [`.protoNames()`](#multiaddrprotonames)\n *\n * @instance\n * @returns {{table: Array, names: Object, codes: Object}}\n *\n */\nMultiaddr.protocols = protocols\n\n/**\n * Returns if something is a Multiaddr that is a name\n *\n * @param {Multiaddr} addr\n * @returns {Bool} isName\n */\nMultiaddr.isName = function isName (addr) {\n  if (!Multiaddr.isMultiaddr(addr)) {\n    return false\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some((proto) => proto.resolvable)\n}\n\n/**\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\n *\n * @async\n * @param {Multiaddr} addr\n * @returns {Multiaddr[]}\n */\nMultiaddr.resolve = function resolve (addr) {\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n    return Promise.reject(Error('not a valid name'))\n  }\n\n  /*\n   * Needs more consideration from spec design:\n   *   - what to return\n   *   - how to achieve it in the browser?\n   */\n  return Promise.reject(new Error('not implemented yet'))\n}\n\nMultiaddr.resolvers = resolvers\nexports = module.exports = Multiaddr\n"]},"metadata":{},"sourceType":"script"}