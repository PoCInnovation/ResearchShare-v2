{"ast":null,"code":"var _defineProperty = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/thalusa/Documents/ResearchShare-v2/reactrs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar BufferList = require('bl/BufferList');\n\nvar Reader = require('it-reader');\n\nmodule.exports = function LteReader(source) {\n  var _lteReader;\n\n  var reader = Reader(source);\n  var overflow;\n  var lteReader = (_lteReader = {}, _defineProperty(_lteReader, Symbol.asyncIterator, function () {\n    return lteReader;\n  }), _defineProperty(_lteReader, \"next\", function next(bytes) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var value, _yield$reader$next, nextValue, done;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!overflow) {\n                _context.next = 22;\n                break;\n              }\n\n              if (!(bytes == null || overflow.length === bytes)) {\n                _context.next = 6;\n                break;\n              }\n\n              value = overflow;\n              overflow = null;\n              _context.next = 21;\n              break;\n\n            case 6:\n              if (!(overflow.length > bytes)) {\n                _context.next = 11;\n                break;\n              }\n\n              value = overflow.shallowSlice(0, bytes);\n              overflow = overflow.shallowSlice(bytes);\n              _context.next = 21;\n              break;\n\n            case 11:\n              if (!(overflow.length < bytes)) {\n                _context.next = 21;\n                break;\n              }\n\n              _context.next = 14;\n              return reader.next(bytes - overflow.length);\n\n            case 14:\n              _yield$reader$next = _context.sent;\n              nextValue = _yield$reader$next.value;\n              done = _yield$reader$next.done;\n\n              if (!done) {\n                _context.next = 19;\n                break;\n              }\n\n              throw Object.assign(new Error(\"stream ended before \".concat(bytes - overflow.length, \" bytes became available\")), {\n                code: 'ERR_UNDER_READ'\n              });\n\n            case 19:\n              value = new BufferList([overflow, nextValue]);\n              overflow = null;\n\n            case 21:\n              return _context.abrupt(\"return\", {\n                value: value\n              });\n\n            case 22:\n              return _context.abrupt(\"return\", reader.next(bytes));\n\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  }), _defineProperty(_lteReader, \"nextLte\", function nextLte(bytes) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var _yield$lteReader$next, done, value;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return lteReader.next();\n\n            case 2:\n              _yield$lteReader$next = _context2.sent;\n              done = _yield$lteReader$next.done;\n              value = _yield$lteReader$next.value;\n\n              if (!done) {\n                _context2.next = 7;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", {\n                done: done\n              });\n\n            case 7:\n              if (!(value.length <= bytes)) {\n                _context2.next = 9;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", {\n                value: value\n              });\n\n            case 9:\n              value = BufferList.isBufferList(value) ? value : new BufferList(value);\n\n              if (overflow) {\n                overflow.append(value.shallowSlice(bytes));\n              } else {\n                overflow = value.shallowSlice(bytes);\n              }\n\n              return _context2.abrupt(\"return\", {\n                value: value.shallowSlice(0, bytes)\n              });\n\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))();\n  }), _defineProperty(_lteReader, \"return\", function _return() {\n    return reader.return();\n  }), _lteReader);\n  return lteReader;\n};","map":{"version":3,"sources":["/home/thalusa/Documents/ResearchShare-v2/node_modules/it-tar/lte-reader.js"],"names":["BufferList","require","Reader","module","exports","LteReader","source","reader","overflow","lteReader","Symbol","asyncIterator","bytes","length","value","shallowSlice","next","nextValue","done","Object","assign","Error","code","isBufferList","append","return"],"mappings":"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","sourcesContent":["const BufferList = require('bl/BufferList')\nconst Reader = require('it-reader')\n\nmodule.exports = function LteReader (source) {\n  const reader = Reader(source)\n  let overflow\n  const lteReader = {\n    [Symbol.asyncIterator]: () => lteReader,\n    async next (bytes) {\n      if (overflow) {\n        let value\n        if (bytes == null || overflow.length === bytes) {\n          value = overflow\n          overflow = null\n        } else if (overflow.length > bytes) {\n          value = overflow.shallowSlice(0, bytes)\n          overflow = overflow.shallowSlice(bytes)\n        } else if (overflow.length < bytes) {\n          const { value: nextValue, done } = await reader.next(bytes - overflow.length)\n          if (done) {\n            throw Object.assign(\n              new Error(`stream ended before ${bytes - overflow.length} bytes became available`),\n              { code: 'ERR_UNDER_READ' }\n            )\n          }\n          value = new BufferList([overflow, nextValue])\n          overflow = null\n        }\n        return { value }\n      }\n      return reader.next(bytes)\n    },\n    async nextLte (bytes) {\n      let { done, value } = await lteReader.next()\n      if (done) return { done }\n      if (value.length <= bytes) return { value }\n      value = BufferList.isBufferList(value) ? value : new BufferList(value)\n      if (overflow) {\n        overflow.append(value.shallowSlice(bytes))\n      } else {\n        overflow = value.shallowSlice(bytes)\n      }\n      return { value: value.shallowSlice(0, bytes) }\n    },\n    return () {\n      return reader.return()\n    }\n  }\n  return lteReader\n}\n"]},"metadata":{},"sourceType":"script"}